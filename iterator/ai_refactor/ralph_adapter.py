import argparse
import sys
import yaml
from pathlib import Path
from .workflow import run_once
from .git_utils import get_repo_root

def main():
    parser = argparse.ArgumentParser(description="Ralph Adapter for AI Refactor")
    parser.add_argument("--from-prompt", required=True, help="Path to the prompt file generated by Ralph")
    parser.add_argument("--no-branch", action="store_true", help="Skip branch creation (Ralph might handle this)")
    
    args = parser.parse_args()
    
    prompt_path = Path(args.from_prompt)
    if not prompt_path.exists():
        print(f"Error: Prompt file {prompt_path} not found.")
        sys.exit(1)
        
    with open(prompt_path, "r") as f:
        prompt_content = f.read().strip()
        
    # Heuristic to detect task name or just use a generic one
    task_name = "ralph-task" 
    # Try to read task name from prompt if formatted in a specific way, 
    # but usually Ralph sends the "story" or instructions directly.
    
    repo_root = get_repo_root()
    
    print(f"Starting Ralph Loop execution for task in {repo_root}")
    
    # In Ralph loop, we often don't create a new branch strictly every loop if unnecessary,
    # but usually Ralph expects the agent to just Work on the current HEAD.
    # So we ignore --no-branch logic inside python for now (it's handled by caller essentially 
    # or we just work on current HEAD).
    
    result = run_once(
        task_name=task_name,
        repo_root=repo_root,
        use_agents=True,
        auto_commit=True, # Ralph agents usually commit their work
        prompt=prompt_content
    )
    
    if result["decision"] == "SHIP" and result["tests_ok"]:
        print("Cycle completed successfully.")
        sys.exit(0)
    else:
        print(f"Cycle failed or needs revision. Decision: {result['decision']}, Tests passed: {result['tests_ok']}")
        sys.exit(1)

if __name__ == "__main__":
    main()
